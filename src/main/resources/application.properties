server.servlet.contextPath=/v1

#postgres
spring.datasource.url=jdbc:postgresql://localhost:5432/
spring.datasource.driverClassName=org.postgresql.Driver
spring.datasource.username=keycloak
spring.datasource.password=password
#jaeger pergunta do Alexsander
#opentracing.spring.web.skip-pattern=XXX

###Security + Oauth
#security.oauth2.resource.user-info-uri=endereço uri do authorizationServer
#security.oauth2.resource.token-info-uri=endereco do decodificador do token


#jpa
spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true


#Log do Hibernate
###
logging.level.org.hibernate.sql=DEBUG

###Keycloack
##AuthorizationServer

#informa onde o Spring Security pode encontrar nosso authorization server.
spring.security.oauth2.resourceserver.jwt.issuer-uri=${KEYCLOAK_ISSUER_URI:http://localhost:18080/auth/realms/nosso-cartao}
#onde o Spring Security pode encontrar as chaves para conseguir validar a assinatura do token.
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=${KEYCLOAK_JWKS_URI:http://localhost:18080/auth/realms/nosso-cartao/protocol/openid-connect/certs}
#Debug segurança
logging.level.org.springframework.security.oauth2=DEBUG
logging.level.org.springframework.security=DEBUG

### Limitar a stacktrace ao lançar exception
#server.error.include-stacktrace=never

#Actuator

### Habilitar os endpoints que por padrão vem desabilitados (Não recomendável)
### Rencomendável liberar apenas os necessarios (Segurança)
management.endpoints.web.exposure.include=info,health,metrics,prometheus
management.endpoints.prometheus.enabled=true
#Criando duas Labels no prometheus para aplicacao e ambiente
management.metrics.tags.aplicacao=${NOME_DA_APLICACAO:serviço de proposta}
management.metrics.tags.ambiente=${AMBIENTE:desenvolvimento}

###Removendo os não utilizados
management.endpoints.web.exposure.exclude=env,beans

### Permitindo receber requisições somente de uma origem
#management.endpoints.web.cors.allowed-origins=https://localhost:8080
#management.endpoints.web.cors.allowed-methods=GET

###Habilitar mais detalhes do endpoint /health
#management.endpoint.health.show-details=always

###Preenchendo o endpoint info
info.app=Api de Propostas
info.developer=Montival Junior
info.empresa=Zup Innovation

### Sheduling - O Spring permite você definir a periodicidade via propriedade
periodicidade.executa-operacao=50000

proposta.analise.host=${ANALISE_URL:http://localhost:9999}
proposta.cartao.host=${CARTAO_URL:http://localhost:8888}

#Feign

### para controlar o tempo de espera para requisições feitas através do Feign > feign.client.config.nomeFeignClienteDefinidoNoBean.read-timeout=100
feign.client.config.AnaliseClient.read-timeout=1000

### o tempo máximo para conseguir realizar a conexão com o outro sistema > feign.client.config.nomeFeignClienteDefinidoNoBean.connect-timeout=100
feign.client.config.AnaliseClient.connect-timeout=1000



#Hibernate ou outra implementação do JPA

### controlar o timeout de execução padrão de queries através de alguma implementação da JPA.
spring.jpa.properties.javax.persistence.query.timeout=50
### Agora por default toda query só pode levar no máximo 50 milisegundos.
### Caso em algum ponto do sistema este tempo não seja suficiente, é possível de trocar através dos chamados hints da JPA.



