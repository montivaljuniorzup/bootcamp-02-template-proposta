server.servlet.contextPath=/v1
spring.application.name=proposta



###postgres

spring.datasource.url=jdbc:postgresql://localhost:5432/
spring.datasource.driverClassName=org.postgresql.Driver
spring.datasource.username=keycloak
spring.datasource.password=password


###jpa

spring.jpa.hibernate.ddl-auto=create-drop
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true



###Log do Hibernate

logging.level.org.hibernate.sql=DEBUG



###Security + Oauth
###Keycloack
##AuthorizationServer

#informa onde o Spring Security pode encontrar nosso authorization server.
spring.security.oauth2.resourceserver.jwt.issuer-uri=${KEYCLOAK_ISSUER_URI:http://localhost:18080/auth/realms/nosso-cartao}

#onde o Spring Security pode encontrar as chaves para conseguir validar a assinatura do token.
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=${KEYCLOAK_JWKS_URI:http://localhost:18080/auth/realms/nosso-cartao/protocol/openid-connect/certs}

#Debug segurança
#logging.level.org.springframework.security.oauth2=DEBUG
#logging.level.org.springframework.security=DEBUG

### Limitar a stacktrace ao lançar exception
#server.error.include-stacktrace=never



###Actuator


# Habilitar os endpoints que por padrão vem desabilitados (Não recomendável)
# Rencomendável liberar apenas os necessarios (Segurança)
management.endpoints.web.exposure.include=info,health,metrics,prometheus
management.endpoints.prometheus.enabled=true
#Criando duas Labels no prometheus para aplicacao e ambiente
management.metrics.tags.aplicacao=${NOME_DA_APLICACAO:serviço de proposta}
management.metrics.tags.ambiente=${AMBIENTE:desenvolvimento}

#Removendo os não utilizados
management.endpoints.web.exposure.exclude=env,beans

# Permitindo receber requisições somente de uma origem
#management.endpoints.web.cors.allowed-origins=https://localhost:8080
#management.endpoints.web.cors.allowed-methods=GET

#Habilitar mais detalhes do endpoint /health
#management.endpoint.health.show-details=always

#Preenchendo o endpoint info
info.app=Api de Propostas
info.developer=Montival Junior
info.empresa=Zup Innovation




### Sheduling
# O Spring permite você definir a periodicidade via propriedade
periodicidade.executa-operacao=50000


proposta.analise.host=${ANALISE_URL:http://localhost:9999}
proposta.cartao.host=${CARTAO_URL:http://localhost:8888}




###Feign

# para controlar o tempo de espera para requisições feitas através do Feign em milisegundos
feign.client.config.AnaliseClient.read-timeout=1000

# o tempo máximo para conseguir realizar a conexão com o outro sistema
feign.client.config.AnaliseClient.connect-timeout=1000



###Hibernate ou outra implementação do JPA

# controlar o timeout de execução padrão de queries através de alguma implementação da JPA.
spring.jpa.properties.javax.persistence.query.timeout=50
# Agora por default toda query só pode levar no máximo 50 milisegundos.
# Caso em algum ponto do sistema este tempo não seja suficiente, é possível de trocar através dos chamados hints da JPA.



### Jaeger

#Habilita ou não
opentracing.jaeger.enabled=${JAEGER_ENABLED:true}

# Nome do serviço
opentracing.jaeger.service-name=${spring.application.name}

# Endereço para enviar os metadados (trace, span, etc)
opentracing.jaeger.http-sender.url=${JAEGER_ENDPOINT:http://localhost:14268/api/traces}

# Tipo de amostragem (probabilístico) e sua configuração (1 = 100%)
opentracing.jaeger.probabilistic-sampler.sampling-rate=${JAEGER_SAMPLER:1}

###jaeger pergunta do Alexsander
#opentracing.spring.web.skip-pattern=XXX
